----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------SURVEY OF OBJECT ORIENTED PROGRAMMING LANGUAGES------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- INTRODUCTION--------- THIS PAPER WAS INTENDED AS A LEARNING EXPERIENCE FOR THE AUTHOR, IN AN-ATTEMPT TO BETTER UNDERSTAND THE HISTORY AND DEVELOPMENT OF OBJECT-ORIENTED PROGRAMMING LANGUAGES.- THE RESEARCH INVOLVED IN THIS PAPER-BEGAN WITH-A VARIETY OF PAPERS WHICH DEALT WITH THE DEFINITION OF-``OBJECT ORIENTED'' AND FROM THERE SPREAD OUT INTO SEVERAL HISTORIC PAPERS ON-THE ORIGINS OF OBJECT ORIENTED PROGRAMMING IN SIMULA AND SMALLTALK.-FURTHER READING INVOLVED MAINSTREAM REFERENCE MATERIAL ON MANY OF THE-MORE WIDELY USED OBJECT ORIENTED LANGUAGES, IN ADDITION TO HISTORIC-DOCUMENTS ON THEIR DESIGN AND DEVELOPMENT.----- DUE TO TIME CONSTRAINTS, THIS PAPER NEVER ACHIEVED THE SCOPE THAT THE-AUTHOR HAD- INTENDED FOR IT, AND MUCH OF THE RESEARCH DONE IS NOT-REFLECTED IN THESE PAGES.----------------------------------------------------^1 THIS PAPER ONLY ATTEMPTS TO LOOK AT THE MEANING-OF ``OBJECT ORIENTED'' AS A PROPERTY OF PROGRAMMING LANGUAGES, AS WELL-AS TO EXAMINE THE HISTORY, AND FEATURES OF EIGHT PARTICULAR OBJECT-ORIENTED LANGUAGES.- IT IS DIVIDED INTO FOUR SECTIONS:----------------------------------------------- INTRODUCTION:-------- THIS SECTION.----------------------------- NOTION OF OBJECT ORIENTEDNESS:-------- DISCUSSION OF VARIOUS-AUTHORS FEELING ON OOP.----------------------------- SOME LANGUAGES:-------- A LOOK AT THE HISTORY, DEVELOPMENT-,DESIGN, AND FEATURES OF PREDOMINANT OOPLS.----------------------------- RESEARCH REFERENCES:-------- REFERENCES USED FOR THIS RESEARCH PROJECT.-------------------------------------------------------------------- NOTION OF OBJECT ORIENTEDNESS---------- WHAT DOES IT MEAN FOR SOMETHING TO BE OBJECT ORIENTED?- WHAT-EXACTLY IS AN ``OBJECT ORIENTED PROGRAMMING LANGUAGE?''- THESE-ARE QUESTIONS THAT NO ONE CAN ANSWER VERY WELL.- AS TIM RENTSCH SAID:------------------------ ``...OBJECT ORIENTED PROGRAMMING WILL BE IN THE 1980'S- WHAT STRUCTURED PROGRAMMING WAS IN THE 1970'S.- EVERYONE WILL- BE IN FAVOR OF IT.- EVERY MANUFACTURER WILL PROMOTE HIS- PRODUCTS AS SUPPORTING IT.- EVERY MANAGER WILL PAY LIP SERVICE- TO IT. EVERY PROGRAMMER WILL PRACTICE IT (DIFFERENTLY).- AND- NO ONE WILL KNOW JUST WHAT IT IS.-----'' [RENTSCH-------------------82] GENERALLY SPEAKING, RENTSCH WAS RIGHT NOT ONLY ABOUT THE 1980'S, BUT THE 1990'S AS WELL.- WITH ALL THE VARIOUS ``OBJECT ORIENTED PROGRAMMING LANGUAGES'' AND ``OBJECT ORIENTED PROCESSES'' AND ``OBJECT ORIENTED BASKET WEAVING'' IN THE WORLD TODAY, IT SEEMS THAT ESTABLISHING A CLEAR DEFINITION OF WHAT IT MEANS TO BE OBJECT ORIENTED, IS IMPOSSIBLE.----- IT WOULD APPEAR THAT INSTEAD OF ATTEMPTING TO FIND A COHERENT DEFINITION, A BETTER APPROACH IS TO ACCEPT THE IDEA THAT PROGRAMMING LANGUAGES, OR PROCESSES (OR WIDGETS) CAN NOT ``BE OBJECT ORIENTED.''-INSTEAD, WE SHOULD CONSIDER OBJECT ORIENTEDNESS AS A ``NOTION''-WHICH CAN BE ASSOCIATED WITH SYSTEMS, PROGRAMS--LANGUAGES, ETC...- OR SIMILARLY- AS A PROPERTY THAT SOMETHING CAN EXHIBIT.- BUT JUST BECAUSE ONE FACET OF A SYSTEM HAS OBJECT ORIENTED PROPERTIES, DOES NOT MEAN THAT THE SYSTEM AS A WHOLE (OR EVEN OTHER POTIONS OF THE SYSTEM) IS OBJECT ORIENTED.----- WHEN DEALING SPECIFICALLY WITH PROGRAMMING, AND PROGRAMMING LANGUAGES, IT IS IMPORTANT TO KEEP IN MIND 3 PRINCIPLES:---------------- A DESIGN CAN BE OBJECT ORIENTED, EVEN IF THE RESULTING PROGRAM ISN'T.----------------- A PROGRAM CAN BE OBJECT ORIENTED, EVEN IF THE LANGUAGE IT'S-WRITTEN IN ISN'T.----------------- AN OBJECT ORIENTED PROGRAM CAN BE WRITTEN IN ALMOST ANY LANGUAGE, BUT A LANGUAGE CAN'T BE ASSOCIATED WITH OBJECT ORIENTEDNESS UNLESS IT----- PROMOTES----- OBJECT ORIENTED PROGRAMS.------------------------------- BUT ALL OF THIS SIDE STEPS THE ISSUE THAT PEOPLE ULTIMATELY WANT TO UNDERSTAND: ``WHAT MAKES PROGRAMMING LANGUAGES OBJECT ORIENTED?''- TO ADDRESS THIS QUESTION, CONSIDER SOME EXCERPTS (FROM AN ASSORTMENT OF PAPERS) THAT ATTEMPT TO CLARIFY THE ISSUE:------------------------ ``THE FIRST PRINCIPLE OF OBJECT ORIENTED PROGRAMMING- MIGHT BE CALLED----- INTELLIGENCE ENCAPSULATION:----- VIEW- OBJECTS FROM OUTSIDE TO PROVIDE A NATURAL METAPHOR OF- INTRINSIC BEHAVIOR. ... IT FOLLOWS THAT THERE IS NO WAY OF- OPENING UP AN OBJECT AND LOOKING AT IT'S INSIDES, OR UPDATING- (``SMASHING'') ITS STATE.- WHAT IS MORE IMPORTANT IS THAT THE- CONCEPT OF OPENING UP AN OBJECT DOES NOT EXIST IN THE LANGUAGE.-----''-------------------------------------------------- ``... A MESSAGE IS A REQUEST OF WHAT THE SENDER WANTS- WITH NO HINT OR CONCERN AS TO WHAT THE RECEIVER SHOULD DO TO- ACCOMMODATE THE SENDER'S WISHES. ... THIS NOTION, A SORT OF------ CALL BY DESIRE-----, IS CENTRAL TO THE OBJECT ORIENTED- PHILOSOPHY-----''-------------------------------------------------- ``... ATTRIBUTES CAN BE SHARED BY A GROUP WHILE- ALLOWING FOR INDIVIDUALS WITHIN THE GROUP TO REINTERPRET SOME- ``SHARED'' BEHAVIOR----- AS IT APPLIES TO THE INDIVIDUALS- THEMSELVES-----. ... THE RESULT OF ALLOWING INDIVIDUAL- VARIABILITY IS THAT, GIVEN SOMETHING CLOSE TO WHAT YOU WANT-, IT IS EASY TO PRODUCE EXACTLY WHAT YOU WANT BY OVERRIDING- SHARED BEHAVIOR WITH INDIVIDUAL BEHAVIOR - TO----- ADAPT----------''--------------------------------------------------- ``... THE ENTIRE THRUST OF ITS DESIGN HAS BEEN TO SUPERCEDE- THE CONCEPT OF DATA AND PROCEDURES ENTIRELY; TO REPLACE THESE- WITH THE MORE GENERALLY USEFUL NOTIONS OF ACTIVITY-, COMMUNICATION, AND INHERITANCE.-----'' ALAN KAY IN-------------------------------------------------- ``IF THE TERM ``OBJECT-ORIENTED PROGRAMMING LANGUAGE''- MEANS ANYTHING IT MUST MEAN A PROGRAMMING LANGUAGE THAT- PROVIDES A MECHANISM THAT SUPPORTS THE OBJECT-ORIENTED STYLE- OF PROGRAMMING WELL.-----''----------------------------------------------------- ``THE BASIC SUPPORT A PROGRAMMER NEEDS TO WRITE- OBJECT-ORIENTED PROGRAMS CONSISTS OF A CLASS MECHANISM WITH- INHERITANCE AND A MECHANISM THAT ALLOWS CALLS OF MEMBER- FUNCTIONS TO DEPEND ON THE ACTUAL TYPE OF AN OBJECT (IN CASES- WHERE THE ACTUAL TYPE IS UNKNOWN AT COMPILE TIME).-----''---------------------------------------------------------- ``OBJECT-ORIENTED PROGRAMMING:----- A PROGRAM- EXECUTION IS REGARDED AS A----- PHYSICAL MODEL-----, SIMULATING- THE BEHAVIOR-OF EITHER A REAL OR IMAGINARY PART OF THE- WORLD.-----''------------------------------------------------- ``... SUCH A LANGUAGE SHOULD SUPPORT:---------------------------------- MODELLING OF CONCEPTS AND PHENOMENA, I.E. THE LANGUAGE- MUST INCLUDE CONSTRUCTS LIKE CLASS,TYPE, PROCEDURE.------------------ MODELLING CLASSIFICATION HIERARCHIES, I.E. SUB-CLASSING- (INHERITANCE) AND VIRTUALS.------------------ MODELLING ACTIVE OBJECTS, I.E. CONCURRENCY OR COROUTINE- SEQUENCING, COMBINED WITH PERSISTENCY.-----''------------------------------------------------------- ``OBJECT ORIENTED PROGRAMMING:- THE COMPUTING PROCESS IS- VIEWED (AS DESCRIBED ABOVE) AS THE DEVELOPMENT OF A SYSTEM-, CONSISTING OF OBJECTS (COMPONENTS), THROUGH SEQUENCES OF- CHANGING STATES.-----''-------------------------------------------------- ``THE OBJECT-ORIENTED APPROACH COMBINES THREE- PROPERTIES: ENCAPSULATION, INHERITANCE, AND ORGANIZATION-----''------------------------------------ IN ADDITION TO THE ABOVE PASSAGES, IT IS IMPORTANT TO KEEP IN MIND-SOME ITEMS WHICH MAY (MISLEADINGLY) SEEM OBJECT ORIENTED:------------------------ ``OBJECT ORIENTED PROGRAMMING IS----- NOT----- PROGRAMMING- USING A SIMULA-LIKE CLASS CONCEPT, JUST AS STRUCTURED- PROGRAMMING IS NOT GOTO-LESS PROGRAMMING.-----''------------------------------------------------------- ``[SIMULA...-----] ... ALSO INCLUDED MANY- ``FEATURES'' SUCH AS INSPECT AND IN, WHICH ARE CONTRARY TO THE- OBJECT ORIENTED PHILOSOPHY.-----''-------------------------------------------------- ``CONSIDER A LANGUAGE HAVING AN INHERITANCE MECHANISM- WITHOUT VIRTUAL FUNCTIONS OR METHODS.- COULD THAT LANGUAGE BE- SAID TO SUPPORT OBJECT-ORIENTED PROGRAMMING?- I THINK NOT...-----''----------------------------------------------------- ``THINKING OBJECT-ORIENTED DOES NOT HAVE TO EXCLUDE- FUNCTIONAL EXPRESSIONS WHEN THAT IS MORE NATURAL.- FUNCTIONS-, TYPES AND VALUES ARE IN FACT NEEDED IN ORDER TO DESCRIBE- MEASURABLE PROPERTIES OF OBJECTS.-----''------------------------------ TO SUMMARIZE THESE IDEAS, WE CAN SAY THAT FOLLOWING FEATURES ARE-OBJECT ORIENTED PROPERTIES - AND THAT PROGRAMMING LANGUAGES WHICH-ACTIVELY SUPPORT THEM, CAN BE ASSOCIATED WITH OBJECT ORIENTEDNESS.---------------- OBJECTS...-------------- AUTONOMOUS ENTITIES------- NO DIRECT ACCESS TO THEIR COMPONENTS--, OR RUN TIME TYPE------------------------------------------------------------^2 INTERACT PURELY BY MESSAGES, WITH NO ASSUMPTION OF IMPLEMENTATION------------------ OBJECT ORGANIZATION...-------------- INHERITANCE MECHANISM TO CONSTRUCT AN-- OBJECT CLASSIFICATION HIERARCHY------- NOT JUST FOR CODE SHARING------- MUST HAVE ABSTRACT NODES IN HIERARCHY FOR-- MORE REALISTIC MODELING------- PROVIDE POTENTIAL FOR INDIVIDUALITY IN OBJECTS------- DYNAMICLY DETERMINE (VIA RUN TIME TYPE) CORRECT RESPONSE-- TO MESSAGES------------------ PROGRAMS AS MODELS...-------------- PROGRAMS MODEL THE DEVELOPMENT OF SOME PLANNED SYSTEM------- CHANGING STATE OF SYSTEM REFLECTED BY THE CHANGING-- STATE OF THE OBJECTS------- OBJECTS CAN BE THOUGHT OF AS ACTING CONCURRENTLY------- SUPPORT FOR ``NON OO'' PROGRAMMING TECHNIQUES IN SITUATIONS WHERE-- THEY MAKE SENSE-------------------------------------------------------------------------- SOME LANGUAGES-------------------------------------------------- SIMULA----------------------------------------------------- CREATORS---------- DEVELOPED AT THE NORWEGIAN COMPUTING CENTER BY KRISTEN NYGAARD AND OLE-JOHAN DAHL.------------------------------------------------- INFLUENCES---------- ALGOL 60 (AS A SUBSET).------------------------------------------------ DEVELOPMENT TIME-LINE---------- IN 1961 NYGAARD WAS WORKING FOR THE NORWEGIAN COMPUTING CENTER (NCC)-,DOING WORK WITH SIMULATIONS AND SYSTEM ANALYSIS.- NYGRAAD FELT THAT INSTEAD OF USING EXISTING TOOLS, THE BEST WAY TO APPROACH SIMULATION PROGRAMMING, WOULD BE TO HAVE A SPECIAL PURPOSE SIMULATION PROGRAMMING LANGUAGE-,THAT COULD BE USED TO MODEL SYSTEMS EASILY.- WITH HIS BACKGROUND IN SIMULATIONS, HE TEAMED UP WITH DAHL (AN-EXPERIENCED PROGRAMMER WITH EXPERIENCE IN LANGUAGE DESIGN) IN----------- NYGAARD AND DAHL PROPOSED THEIR IDEA FOR A SIMULATION LANGUAGE IN-1963, AND ALTHOUGH THEIR IDEAS-DID NOT RECEIVE MUCH-ENTHUSIASM, POLITICAL ISSUES AT THE NCC RESULTED IN A CONTRACT BETWEEN THE NCC AND-UNIVAC TO PROVIDE A SIMULA IMPLEMENTATION AND COMPILER BY 1965 - NCC DID SO, AND THE RESULT IS KNOWN AS ``SIMULA-I''.- REFINEMENTS WERE MADE-TO SIMULA I AND IN 1967 ``SIMULA-67'' WAS RELEASED.- THE MOST RECENT-STANDARD IS SIMULA-----------------------------------------------------FEATURES AND DESIGN---------- SIMULA STARTED OUT AS AN ACTIVITY/PROCESS BASED PROGRAMMING LANGUAGE, IN-WHICH DIFFERENT TYPES (AND BEHAVIOR) OF ACTIVITIES ARE DECLARED, AND-THEN MULTIPLE PROCESSES CAN BE CREATED TO CARRY OUT DIFFERENT-ACTIVITIES.- THE KEY POWER IN THIS ORIGINAL DESIGN, WAS THAT IN-ADDITION TO HAVING LISTS OF ACTIONS TO BE PERFORMED, PROCESSES WERE-ALSO DATA STRUCTURES, AND ACTIVITIES HAS ASSOCIATED METHODS.- THESE-ACTIVITIES-AND PROCESSES HAD SO-MUCH USE-BESIDES JUST THAT OF-SIMULATION, THAT WHEN SIMULA----WAS RELEASED, THEY HAD BEEN RENAMED-``CLASSES'' AND ``OBJECTS'' (THUS THE BIRTH OF ``OBJECT ORIENTED''-PROGRAMMING).----- IN ADDITION TO ALL THE FEATURES OF ALGOL 60, SIMULA ADDED SUPPORT FOR OBJECTS (AS CLOSURES WHICH RETURN REFERENCES TO THEMSELVES) WITH PROTECTED STATE, SINGLE INHERITANCE FOR SUB-TYPING AND CODE SHARING, PARTIALLY ABSTRACT CLASSES, METHOD OVERRIDING, AND NESTED CLOSURES (INCLUDING NESTED PROCEDURES, CLASSES, AND CLASSES LOCAL TO PROCEDURES).----- ITS INTERESTING TO NOTE THAT AS THE FATHER OF OBJECT ORIENTED LANGUAGES, SIMULA-67 DOES NOT SUPPORT DYNAMIC DISPATCH - SOMETHING MOST PEOPLE CONSIDER NECESSARY FOR ``TRUE'' OBJECT ORIENTED PROGRAMMING. INSTEAD, AN OBJECT MUST BE DOWNCAST (ERROR CHECKED AT RUN TIME) AND THE APPROPRIATE ATTRIBUTE/METHOD-CAN THEN BE ACCESSED----------------------------------.----------- SMALLTALK----------------------------------------------------- CREATORS---------- DEVELOPED BY ALAN KAY, DAN INGALLS, AND ADELE GOLDBERG AT XEROX PARC.------------------------------------------------ INFLUENCES---------- B220 TAPES, SKETCHPAD, SIMULA, AND LISP.------------------------------------------------ DEVELOPMENT TIME-LINE---------- IN 1961, ALAN KAY WAS-A PROGRAMMER FOR THE-AIR FORCE, AND NOTICED THAT SOMEONE HAD DESIGNED A SYSTEM FOR ``BURROUGHS 220'' MAGNETIC TAPES IN WHICH THE DATA ON THE TAPE COULD BE OF ARBITRARY FORMAT AND SIZE, THE BEGINNING OF THE TAPE CONTAINED THE ACTUAL CODE NECESSARY TO EXTRACT THE PARTICULAR TYPE OF DATE (THIS WOULD EVENTUALLY COME TO BE KNOWN AS ENCAPSULATING CODE AND DATE INTO OBJECTS).----- IN 1966, KAY WENT TO GRADUATE SCHOOL AT THE UNIVERSITY OF UTAH, ON HIS FIRST DAY HE WAS HANDED A PACKET OF ORIENTATION INFORMATION - WHICH INCLUDED A PAPER ON ``SKETCHPAD'' BY IVAN SUTHERLAND - AND FOUND ON HIS DESK A PILE OF TAPES AND PRINTOUTS WITH THE NOTE ``THIS IS THE ALGOL FOR THE------ IT DOESN'T WORK, PLEASE MAKE IT WORK.''----- STARTING WITH THE PACKET OF INFORMATION, KAY WAS FASCINATED BY SUTHERLAND'S PAPER.- SKETCHPAD WAS A REVOLUTIONARY GRAPHICS WORKSTATION-(FOR IT'S TIME) WHICH AMONG OTHER THINGS: ENABLED THE USER TO CREATE-``MASTER DRAWINGS'' AND FROM A MASTER, CREATE MULTITUDES OF ``INSTANCE DRAWINGS'' WITH THEIR OWN DISTINCT CHARACTERISTICS.- IN ADDITION, THE DATA STRUCTURES USED BY SKETCHPAD WERE SIMILAR-TO THE B220 TAPES HE HAD SEEN IN THE AIR-FORCE, WITH EMBEDDED POINTERS FOR MODIFYING THE STRUCTURE.----- KAY EVENTUALLY GOT TO WORK ON THE ``ALGO''-PRINTOUTS ON HIS DESK, AND WAS THOROUGHLY CONFUSED, THERE WERE MANY CONSTRUCTS HE HAD NEVER SEEN BEFORE AND ``THE DOCUMENTATION READ LIKE NORWEGIAN TRANSLATED INTO ENGLISH.''[KAY-93] WHAT KAY HAD INADVERTENTLY BEEN GIVEN WAS A COPY OF SIMULA-I.- LOOKING OVER THE PRINTOUTS, AND READING THE DOCUMENTATION, HE REALIZED THE IMMENSE POTENTIAL OF PROGRAMMING WITH CONSTRUCTS LIKE SIMULA'S ACTIVITIES AND PROCESSES, OR SKETCHPAD'S MASTERS AND INSTANCES.- KAY QUICKLY DEVELOPED A VAGUE IDEA FOR PROGRAMMING BY NOT ONLY BREAKING THE PROBLEM DOWN INTO SMALLER SUB-PROBLEMS, BUT BY BREAKING-THE COMPUTER DOWN INTO THOUSANDS OF SMALLER SIMULATED COMPUTERS (OR OBJECTS) TO SOLVE ALL OF THE SUB PROBLEMS.----- KAY BEGAN WORKING ON ``PERSONAL COMPUTERS'' WITH AN EYE TOWARDS AN-``OBJECT ORIENTED'' INTERFACE.- IN 1970 LEFT UTAH TO WORK FOR-XEROX-PARC, AND BEGAN DEVELOPING A DESKTOP COMPUTER OR USE BY CHILDREN CALLED---KIDDIKOMP'' (LATER `-MINICOM'') WHICH HAD A COMBINATION PROGRAMMING LANGUAGE / USER INTERFACE CALLED SMALLTALK----) TO STRESS IT'S EASE OF USE.----- SMALLTALK WAS REDEFINED FROM SCRATCH IN 1972 ON A BET, (THAT KAY COULD DEFINE THE ``MOST POWERFUL LANGUAGE IN THE WORLD'' IN ``A PAGE OF CODE'') AND SMALLTALK-72 HAS SINCE BEEN CONSIDERED THE FIRST "REAL SMALLTALK". SMALLTALK WAS REDESIGNED AGAIN IN 1976 BY DAN INGALLS, AND THEN AGAIN IN 1980 JUST BEFORE IT WAS RELEASED TO THE PUBLIC.------------------------------------------------ FEATURES AND DESIGN---------- SMALLTALK IS AN UNTYPED, CLASS BASED LANGUAGE.- TO BETTER MODEL THE DIFFERENCE BETWEEN PERFORMING ACTIONS ON TYPES OF OBJECTS, AND ON A DISTINCT OBJECT, SMALLTALK CLASSIFIES ATTRIBUTES AND METHODS AS BELONGING TO EITHER THE CLASS OR TO INSTANCES.- CLASS METHODS ARE LOCATED IN THE CLASS META-OBJECT AND CAN ONLY REFER TO CLASS ATTRIBUTES (ALSO LOCATED IN THE META-OBJECT TO PROVIDE SHARED STATE FOR ALL INSTANCES).- INSTANCE METHODS ARE KEPT LOCALLY TO EACH OBJECT AND CAN REFER TO BOTH THE CLASS VARIABLES AND THE INSTANCE VARIABLES (WHICH PROVIDE LOCAL STATE) ALL METHODS ARE PUBLIC, WHILE ALL ATTRIBUTES ARE PRIVATE.------ SINGLE INHERITANCE IS PROVIDED, ALONG WITH (PARTIALLY) ABSTRACT CLASSES, AND METHOD OVERRIDING (INCLUDING SIGNATURE MODIFICATION). ALTHOUGH SMALLTALK IS UNTYPED, THE MAIN PURPOSE OF INHERITANCE IS NOT-JUST CODE SHARING.- THE UNDERLYING PRINCIPLE IS SIMILAR TO SUB-TYPING IN THAT PROGRAMMERS SHOULD USE INHERITANCE TO PROVIDE SPECIALIZATION OF OBJECTS, AND CAN SUBSEQUENTLY FEEL SECURE THAT IT WILL BE SAFE TO USE AN INSTANCE OF A SUBCLASS AS IF IT WERE AN INSTANCE OF THE SUPERCLASS --WITHOUT HAVING TO WORRY ABOUT RUN TIME ERRORS.--------------------------------------------- MODULA------------------------------------------------------3 CREATORS---------- DESIGNED BY LUCA CARDELLI, JIM DONAHUE, MICK JORDAN, BILL KALSOW, GREG-NELSON.- THE SPECIFICATION WAS WRITTEN BY LUCILLE GLASSMAN AND GREG NELSON .------------------------------------------------ INFLUENCES---------- MODULA-2+ (AND FROM IT: MODULA-2, MESA, CEDAR).------------------------------------------------ DEVELOPMENT TIME-LINE---------- IN NOVEMBER OF 1986 MAURICE WILKES PROPOSED THAT THE IDEAS IN MODULA-2+ BE FORMALIZED INTO A NEW STANDARDIZED LANGUAGE IN THE MODULA FAMILY.- AS A RESULT THE MODULA-3 COMMITTEE WAS FORMED BY DIGITAL EQUIPMENT CORPORATION IN COOPERATION WITH THE OTIVETTI RESEARCH CENTER.- THE INITIAL LANGUAGE DEFINITION WAS PUBLISHED IN AUGUST OF 1988, AND THEN REVISED (BASED ON THE RECOMMENDATIONS OF IMPLEMENTORS) IN JANUARY OF------------------------------------------------------ FEATURES AND DESIGN---------- MODULA-3 IS A CLASS BASED LANGUAGE IN WHICH CLASS NAMES ACT AS- TYPE NAMES - THERE ARE NO EXPLICIT TYPE DEFINITIONS OR DECLARATIONS.----- CLASS DEFINITIONS ARE ``PARTIAL OPAQUE'' - MEANING THAT METHODS AND ATTRIBUTES MAY OR MAY NOT BE VISIBLE TO OTHER CLASSES.- SINGLE INHERITANCE IS PROVIDED AS A MEANS OF TYPE SPECIALIZATION, (ALLOWING SUB-CLASSES TO OVERRIDE THE METHODS OF THEIR SUPER-CLASS) WHICH ALSO PROVIDES CODE REUSE, AND ABSTRACT CLASSES ARE ALLOWED AS A MEANS TOS PECIFY TYPES (WHICH CONTAIN ONLY METHOD DECLARATIONS AND SIGNATURES) WITHOUT IMPLEMENTATIONS.----- IN ADDITION TO INHERITANCE AS A METHOD OF CLASS SPECIFICATION, MODULA-3 PROVIDES GENERIC MODULES WHICH ARE TEMPLATES PARAMETERIZED BY TYPES.- GENERICS ARE NOT POLYMORPHIC, AND PROVIDE ONLY SOURCE CODE REUSE (NOT TARGET CODE REUSE).----- MODULA-3 IS STRONGLY TYPED, WITH NO AUTOMATIC CONVERSION, OR TYPE INFERENCE.- IN ADDITION, MODULA-3 DEFINES TYPE EQUALITY BASED ON TYPE/CLASS STRUCTURE, AND NOT TYPE/CLASS NAME:------------------------ ``TWO TYPES ARE THE SAME IF THEIR DEFINITIONS BECOME THE SAME-WHEN EXPANDED; THAT IS, WHEN ALL CONSTANT EXPRESSIONS ARE REPLACED BY-THEIR VALUES AND ALL TYPE NAMES ARE REPLACED BY THEIR DEFINITIONS.- IN-THE CASE OF RECURSIVE TYPES, THE EXPANSION IS THE INFINITE LIMIT OF-THE PARTIAL EXPANSIONS.-----''------------------------------- BEYOND MODULA-3'S OBJECT ORIENTED FEATURES, IT ALSO PROVIDES LIGHTWEIGHT THREADS, EXCEPTIONS, MODULES, AND MODULE INTERFACES( SIMILAR TO C HEADER FILES--BUT MORE RESTRICTIVE-.- THE LANGUAGE DEFINITION ALSO PROVIDES A MEANS FOR PROGRAMMERS TO OVERRIDE THE COMPILERS SAFETY CHECKS ON PARTICULAR MODULES BY DECLARING THEM-UNSAFE.--------------------------------------------- SELF----------------------------------------------------- CREATORS---------- DAVID UNGAR AND RANDALL SMITH.------------------------------------------------ INFLUENCES---------- SELF WAS MOST HEAVILY-INFLUENCED BY SMALLTALK,-BUT BORROWS FROM A WIDE VARIETY OF PROTOTYPE BASED RESEARCH LANGUAGES (SPECIFICALLY ``O'' BY PETER-DEUTSCH).------------------------------------------------ DEVELOPMENT TIME-LINE---------- SELF WAS INITIALLY DESIGNED IN 1986, AND THE LANGUAGE DESIGN WAS RELEASED IN------- THE FIRST PUBLIC IMPLEMENTATION WAS RELEASED BY STANFORD IN 1991, THE MOST RECENT RELEASE IS SELF 4.0 FROM SUN MICROSYSTEMS IN------------------------------------------------------ FEATURES AND DESIGN---------- SELF IS A CLASSLESS LANGUAGE, WHICH USES PROTOTYPE OBJECTS, AND CLONING TO CONSTRUCT NEW OBJECTS.- THE RUN-TIME ENVIRONMENT IS RESPONSIBLE FOR PERFORMING DYNAMIC TYPE CHECKING, AND THERE ARE NO STATIC TYPES, OR TYPE DECLARATIONS REQUIRED (OR EVEN INCLUDED) IN THE LANGUAGE.------ THE FUNDAMENTAL PRINCIPLE OF SELF IS ``MESSAGES-AT-THE-BOTTOM''.- ALL OPERATIONS ARE IMPLEMENTED AS MESSAGES.- EVERY OBJECT IS COMPOSED ENTIRELY OF SLOTS, WHICH CONTAIN EITHER STATE, OR BEHAVIOR.- WHEN A MESSAGE IS RECEIVED BY AN OBJECT, THE SLOTS OF THE OBJECT ARE CHECKED FOR THE CORRESPONDING MESSAGE.- IF THE MESSAGE IS NOT FOUND IN ONE OF THE OBJECTS SLOTS, THEN THE POINTER IN THE SLOT NAMED ``PARENT'' (WHICH EVERY OBJECT HAS AS A RESULT OF CLONING) IS ACCESSED, AND THE MESSAGE LOOKUP ON THE SLOTS RECURSES UP THE PARENT POINTERS.----- ONCE THE APPROPRIATE SLOT IS FOUND, THE CONTENTS OF THE SLOT ARE EITHER A POINTER TO ANOTHER OBJECT (A VARIABLE) OR A METHOD.- METHODS CAN BE THOUGHT OF AS ``PROTOTYPE ACTIVATION RECORDS'' WHEN A SLOT CONTAINING A PROTOTYPE ACTIVATION RECORD IS ACCESSED, IT IS CLONED (INTO AN ACTUAL ACTIVATION RECORD), AND THE A POINTER TO THE OBJECT WHICH WAS SENT THE ORIGINAL MESSAGE IS STORED IN THE ``PARENT'' SLOT (WHICH CAN BE THOUGHT OF AS A SELF POINTER FOR THE SCOPE OF THE METHOD)----- IN THIS MANNER, INHERITANCE, SHARED STATE, CODE SHARING, AND DYNAMIC DISPATCH ARE ALL PROVIDED VIA SLOTS, MESSAGES, AND CLONING.------IN ADDITION, EACH SLOT OF AN OBJECT CAN BE THOUGHT OF AS MEMORY ADDRESS WHICH CAN BE REASSIGNED AT WILL.- THUS NOT ONLY CAN METHODS BE MODIFIED-IN THE MIDDLE OF PROGRAM EXECUTION, BUT ATTRIBUTES CAN BE CHANGED INTO METHODS, AND VICE-VERSA.--------------------------------------------- EIFFEL----------------------------------------------------- CREATORS---------- EIFFEL WAS DESIGNED BY BERTRAND MEYER AT INTERACTIVE SOFTWARE ENGINEERING.------------------------------------------------ INFLUENCES---------- THE OO ASPECTS OF EIFFEL WERE DIRECTLY INFLUENCED BY SIMULA67, WHILE THE ``DESIGN BY CONTRACT'' ASPECTS OF THE LANGUAGE WERE HEAVILY INFLUENCED BY MEYER'S EARLIER ACADEMIC WORK IN SOFTWARE VERIFICATION.------------------------------------------------ DEVELOPMENT TIME-LINE---------- THE INITIAL IDEAS FOR EIFFEL WERE CONCEIVED IN SEPTEMBER OF 1985, AND SUBSEQUENTLY RELEASED TO THE PUBLIC (AS ISE EIFFEL 1) IN OCTOBER OF------- EIFFEL IS STILL EVOLVING, AND THE LATEST VERSION IS ISE EIFFEL--------------------------------------------------- FEATURES AND DESIGN---------- EIFFEL IS A CLASS BASED LANGUAGE, IN WHICH THE DEFINITION OF ``TYPE''-AND ``CLASS'' ARE IDENTICAL.- TYPE EQUIVALENCE IS BASED ON CLASS NAME EQUIVALENCE.------------------------------------------------------------ CLASSES MAY CONTAIN (MULTIPLE) FEATURE CLAUSES WHICH CAN IN TURN CONTAIN MULTIPLE ATTRIBUTES/VALUES AND ROUTINES/PROCEDURES.- THE CLASSIFICATION OF A GIVEN FEATURE (ROUTINE OR ATTRIBUTE) IS UNKNOWN TO OTHER CLASSES, IE: AN ATTRIBUTE OF TYPE T HAS THE SAME ``APPEARANCE'' AS A ROUTINE WHICH TAKES NO ARGUMENTS AND RETURNS AN ITEM OF TYPE T.-EACH FEATURE LIST HAS AN ASSOCIATED CLIENT LIST SPECIFYING THE CLASSES (OF OBJECTS) WHICH ARE PERMITTED TO ACCESS THOSE PARTICULAR FEATURES. CLASSES MAY ALSO DEFER THE IMPLEMENTATION OF ANY FEATURE, MAKING IT-(AND ANY SUB-CLASS WHICH DOES NOT PROVIDE AN IMPLEMENTATION FOR EACH DEFERRED FEATURE) AN ABSTRACT CLASS.----- GENERICITY CLASSES-ARE CLASS TEMPLATES DECLARED WITH FORMAL GENERIC PARAMETERS WHICH MAY BE CONSTRAINED BY A SUPER-CLASS.- INSTANTIATING A GENERIC CLASS REQUIRES AN ACTUAL GENERIC PARAMETER (WHICH IS A SUB-CLASS OF THE SPECIFIED CONSTRAINT) FOR EACH FORMAL PARAMETER. THESE GENERIC CLASSES PROVIDE SOURCE CODE REUSE, BUT NOT TARGET CODE-REUSE.----- EIFFEL SUPPORTS MULTIPLE INHERITANCE (INCLUDING CODE REUSE)-WITH COMPILER ENFORCED RENAMING OF CONFLICTING FEATURES.- IN ADDITION, EIFFEL ALLOWS THE PROGRAMMER TO NOT ONLY REDEFINE (OR UNDEFINE) THE IMPLEMENTATION OF PARTICULAR FEATURES, BUT ALSO MODIFY THE CLIENT LIST OF INHERITED FEATURES.----- AN INTERESTING ``FEATURE'' OF THE EIFFEL SPECIFICATION, IS THAT FEATURE REDEFINITION IS COVARIANT.- THE REASONING IS THAT FOR MOST SITUATIONS, COVARIANCE IS MORE USEFUL THEN CONTRAVARIANCE, AND EVEN THOUGH THE LANGUAGE SPECIFICATION ALLOWS THE POSSIBILITY OF THE RUN-TIME TYPE ERRORS, IT IS THE RESPONSIBILITY OF THE COMPILER TO CATCH THESE SITUATIONS.- BUT, AS THE EIFFEL FAQ ADMITS:------------------------ ``NO COMPILER AVAILABLE TODAY IMPLEMENTS FULL STATIC TYPE- CHECKING. SOME INSERT RUN-TIME CHECKS.-----'' [ARNAUD--------------------98] ONE OF THE MOST PREDOMINANT FEATURES OF EIFFEL IS BUILT IN SUPPORT FOR ``DESIGN BY CONTRACT'', WHICH IS NOT NECESSARILY OBJECT ORIENTED, BUT WORKS WELL WITH OBJECT ORIENTED DESIGN PROCESSES.- EIFFEL PROVIDES ASSERTIONS IN THE FORM OF INVARIANTS OVER OBJECTS, AND PRE/POSTCONDITIONS ON INDIVIDUAL ROUTINES.- IN GENERAL, AN ASSERTION-IS A BOOLEAN EXPRESSION WHICH HAS NO EFFECT IF TRUE, BUT OTHERWISE RESULTS IN A RUN TIME EXCEPTION.- PRECONDITIONS ARE EVALUATED PRIOR TO THE BODY OF THE ASSOCIATED ROUTINE (IN THE SCOPE OF THE ROUTINE'S BODY, WITH THE FORMAL PARAMETERS BOUND TO THE ACTUAL ARGUMENTS). POSTCONDITIONS ARE EVALUATED AFTER THE BODY OF THE ASSOCIATED ROUTINE (AGAIN, IN THE SCOPE OF THE ROUTINE'S BODY, WITH THE FORMAL PARAMETERS BOUND TO THE ACTUAL ARGUMENTS).- INVARIANTS ARE EVALUATED AFTER ANY FEATURE IS ACCESSED.----- ASSERTIONS ARE EXTREMELY POWERFUL WHEN COMBINED WITH INHERITANCE. EIFFEL REQUIRES NOT ONLY THAT THE INVARIANTS OF ALL SUPER-CLASSES ARE COMPATIBLE, BUT THAT THE REDEFINITION OF ANY FEATURE MUST EITHER AD-HEAR TO THE INITIAL PRE/POSTCONDITIONS OF THE SUPERCLASS, OR HAVE A WEAKER PRECONDITION AND A STRONGER POSTCONDITION.--------------------------------------------- SATHER----------------------------------------------------- CREATORS---------- SATHER WAS DESIGNED AT THE INTERNATIONAL COMPUTER SCIENCE INSTITUTE. THE INITIAL DESIGNERS WERE STEPHEN OMOHUNDRO, CHU-CHEOW LIM, AND HEINZ SCHMIDT.------------------------------------------------ INFLUENCES---------- THE MAJOR INFLUENCE-TO SATHER'S DESIGN HAS BEEN EIFFEL, BUT IT HAS ALSO BEEN INFLUENCED DIRECTLY BY C, C++--CECIL- CLOS, CLU, COMMON LISP, DYLAN, ML, MODULA-3, OBERON, OBJECTIVE C, PASCAL, SAIL, SCHOOL, SELF, AND SMALLTALK.------------------------------------------------ DEVELOPMENT TIME-LINE---------- THE INITIAL DESIGN FOR SATHER (``VERSION O'') WAS WRITTEN IN THE SUMMER OF 1990, AND RELEASED BY ICSI TO THE PUBLIC IN JUNE OF 1991 (AS VERSION 0.1).- WHILE THE CORE LANGUAGE HAS NOT CHANGED, NEW FEATURES WERE ADDED SLOWLY, LEADING UP TO THE RELEASE OF SATHER 1.0 IN THE SUMMER OF 1994, FOLLOWED BY SATHER 1.1 IN SEPTEMBER-------, THE MAIN ADDITION OF 1.1 WAS THE INCORPORATION OF THREAD SUPPORT FROM PSATHER-(A LANGUAGE WHICH HAD BEEN EVOLVING IN PARALLEL TO SATHER AT ICSI). IN ADDITION TO PSATHER, THE LANGUAGE SATHER-K IS A DERIVATIVE OF SATHER BEING DEVELOPED AT THE UNIVERSITY OF KARLSRUHE IN GERMANY. SATHER-K DIVERGED FROM SATHER WHEN SATHER 1.1 WAS RELEASED IN------------------------------------------------------ FEATURES AND DESIGN---------- SATHER IS A CLASS BASED LANGUAGE WHICH BORROWS A LOT OF IDEAS AND SEMANTICS FROM EIFFEL (SUCH AS GENERIC CLASSES AND EXCEPTIONS) BUT ATTEMPTS TO SIMPLIFY WHERE EVER POSSIBLE.------ LIKE EIFFEL, SATHER PROVIDES PUBLIC AND PRIVATE ATTRIBUTES AND ROUTINES (IN ADDITION TO READ-ONLY ATTRIBUTES).- BUT UNLIKE EIFFEL, SATHER DOES NOT PERMIT EXPLICIT ACCESS LISTS FOR FEATURES.------- SATHER ALSO PROVIDES SUPPORT FOR THE ``DESIGN BY CONTRACT'' PRINCIPLE IN EIFFEL, INCLUDING PRE/POSTCONDITIONS, INVARIANTS, AND GENERALIZED ASSERTS, WHICH ARE STATEMENTS THAT CAN APPEAR IN ANY BLOCK OF CODE AND RESULT IN A FATAL ERROR IF THEY DO-NOT EVALUATE TO TRUE.----- THE BIGGEST DIFFERENCE BETWEEN SATHER AND EIFFEL IS THE INHERITANCE SYSTEM.- IN SATHER, INHERITANCE IS DIVIDED INTO 2 NOTIONS: SUB-TYPING, AND CODE INCLUSION.----- SUB-TYPING IS PROVIDED PURELY AS A METHOD OF TYPE SPECIALIZATION.- A (CONCRETE) CLASS MY BE DECLARED AS A SUB-TYPE OF AN ABSTRACT CLASS, AND ALL OBJECTS OF THE CLASS THEN AUTOMATICALLY CONFORM TO THE TYPE OF THE ABSTRACT CLASS.- AN ABSTRACT CLASS IS ONLY AN INTERFACE CONTAINING ROUTINE AND ATTRIBUTE TYPE SIGNATURES, AND DOES NOT CONTAIN ANY FORM OF IMPLEMENTATION (AND HENCE: CAN NOT BE INSTANTIATED).- EACH CONCRETE CLASS MAY BE A SUB-TYPE OF AT MOST ONE ABSTRACT CLASS, BUT ABSTRACT CLASSES CAN BY SUB-TYPES OF ANY NUMBER OF OTHER ABSTRACT CLASSES.----- IN CONTRAST TO SUB-TYPING, CODE INCLUSION ALLOWS A CLASS TO DIRECTLY IMPORT THE IMPLEMENTATION OF OTHER (MULTIPLE) CLASSES, FOR THE PURPOSE OF CODE REUSE (WITHOUT ANY AFFECT ON THE INCLUDER'S TYPE).- THE INCLUDING CLASS MAY REDEFINE, UNDEFINE, RENAME, OR MODIFY THE ACCESS PERMISSIONS OF ANY INCLUDED ROUTINES OR ATTRIBUTE, WITH COMPILER ENFORCED RENAMING OF NAME CONFLICTS.- SIMILAR TO THE NOTION OF ABSTRACT CLASSES WITH SUB-TYPING, THERE ARE PARTIAL CLASSES, WHICH POSSES NO TYPE (AND HENCE: CAN NOT BE INSTANTIATED) BUT MAY BE INCLUDED BY ANY NUMBER OF CONCRETE CLASSES----- (IT MAY BE CONVENIENT TO THINK OF ABSTRACT CLASSES AS TYPE DECLARATIONS WHICH MULTIPLE CONCRETE CLASSES CAN IMPLEMENT, WHILE PARTIAL CLASSES ARE CODE REPOSITORIES WHICH CAN BY USED BY MULTIPLE CONCRETE CLASSES.)----- THE MOST IMPRESSIVE FEATURE OF SATHER IS THE INCLUSION OF THE TYPE ``SAME'' WHICH IS THE ``SELF TYPE'' DISCUSSED IN OBJECT ORIENTED THEORY, BUT RARELY-IMPLEMENTED IN ACTUAL LANGUAGES.--------------------------------------------- C-----------------------------------------------------++ CREATORS---------- BJARNE STROUSTRUP.------------------------------------------------ INFLUENCES---------- C, SIMULA, AND CPRE (A C PREPROCESSOR WRITTEN BY STROUSTRUP IN 1979 TO-MAKE PSUEDO SIMULA CLASSES).------------------------------------------------ DEVELOPMENT TIME-LINE---------- ``C WITH CLASSES'' WAS RELEASED IN 1980 AS AN ENHANCED VERSION OF C (IMPLEMENTED USING C COMPILERS WITH A PREPROCESSOR) WHICH INCLUDED CLASSES FOR DATA ABSTRACTION.- C WITH CLASSES WAS DESIGNED SO THAT A PREPROCESSOR COULD MAKE DIRECT CONVERSIONS FROM CLASSES TO STRUCTS, BY MAKING MEMBER FUNCTIONS GLOBAL, RENAMING THEM TO INCLUDE THE CLASS NAME AND MODIFYING THE ARGUMENT LIST TO INCLUDE A THE STRUCT EQUIVALENT OF THE METHOD'S CLASS AS THE FIRST ARGUMENT.----- IN 1982 STROUSTRUP BEGAN WORKING AN A BETTER VERSION OF C WITH CLASSES WHICH WOULD BE ``TRUER'' OBJECT ORIENTED SUPERSET OF C.- IN 1983 THE FIRST VERSION OF C++ WAS RELEASED AND MORE ADVANCED OBJECT ORIENTED FEATURES WERE RAPIDLY UNTIL 1995 WHEN THE FIRST COMMERCIAL VERSION WAS RELEASED.- MORE FEATURES (INCLUDING TEMPLATES) WERE CONTINUALLY ADDED UNTIL 1989, AT WHICH TIME C++ OBTAINED SOME LEVEL OF STABILITY (AN ISO STANDARD VERSION OF C++ WAS FINALIZED IN 1998).------------------------------------------------ FEATURES AND DESIGN---------- C++ IS A CLASS BASED LANGUAGE, DESIGNED TO ALLOW THE PROGRAMMER VERY LOW LEVEL CONTROL OVER OBJECT STRUCTURE AND ACCESS.- OBJECT ORIENTED FEATURES OF C-++ INCLUDE: VIRTUAL (ABSTRACT) FUNCTIONS - RESULTING IN VIRTUAL CLASSES, PUBLIC/PRIVATE/PROTECTED ACCESS CONTROL OVER INDIVIDUAL MEMBER-FUNCTIONS AND ATTRIBUTES, FRIEND CLASSES (FOR ALLOWING EXPLICITLY NAMED CLASSES TO ACCESS PRIVATE STATE), NESTED CLASSES, MULTIPLE INHERITANCE (FOR SUB-TYPING AND CODE SHARING) WITH METHOD REDEFINITION, AND TEMPLATED (GENERIC) CLASSES AND FUNCTIONS.----- OTHER GENERAL FEATURES INCLUDE: USER CONTROLLED MEMORY (THE HEAP), DIRECT MEMORY REFERENCES, STATIC TYPE CHECKING, METHOD OVERLOADING, EXCEPTIONS, THREADS, AND EXPLICITLY CONSTRUCTED NAMESPACES.----- UNFORTUNATELY THE LANGUAGE SPECIFICATION DOES NOT GO FAR IN EXPLAINING THE DETAILS OF HOW THESE FEATURES INTERACT, AND MANY IMPLEMENTATIONS ARE INCOMPATIBLE.------------------------------------------------ JAVA----------------------------------------------------- CREATORS---------- DEVELOPED BY-BY JAMES GOSLING, BILL-JOY, AND GUY STEELE AT SUN MICROSYSTEMS.------------------------------------------------ INFLUENCES---------- MODULA-3, C++, AND LISP.------------------------------------------------ DEVELOPMENT TIME-LINE---------- THE PREMISE FOR JAVA AROSE FROM JAMES GOSLING IN 1991, BECAUSE OF THE FRUSTRATIONS HE HAD USING C++ TO PROGRAM EMBEDDED SYSTEMS SOFTWARE FOR ``SMART''- ELECTRONICS DEVICES AT SUN MICROSYSTEMS.- GOSLING BEGAN DEVELOPING THE LANGUAGE ``OAK'' TO BE A SAFE, OBJECT ORIENTED SYSTEMS LANGUAGE.- BY 1993 OAK HAD BEEN RENAMED ``JAVA'' AND SEVERAL PROTOTYPE ELECTRONIC DEVICES THAT HAD BEEN PROGRAMMED WITH JAVA WERE AVAILABLE - BUT THE MARKET DIDN'T SEEM INTEREST.- AROUND THIS TIME, THE WWW WAS DRASTICLY INCREASING IN USE, AND SUN BEGAN TO SEE USES FOR JAVA'S SMALL, SAFE, PLATFORM INDEPENDENT BYTE CODE IN THE ONLINE COMMUNITY.- DURING 1994 THE LANGUAGE WAS REFINED AND EVENTUALLY RELEASED IN AS VERSION 1.0 IN------- AN UPDATE (1.1) WAS RELEASED IN------------------------------------------------------ FEATURES AND DESIGN---------- JAVA IS A CLASS BASED LANGUAGE, THAT WAS ORIGINALLY DESIGNED FOR PROGRAMMING EMBEDED SYSTEMS.- BECAUSE OF THIS, THE IDEAS OF SPEED, PLATFORM INDEPENDENCE, AND RUN TIME SAFETY ARE CRUCIAL IN IT'S DESIGN.- AS THE MOTIVATION BEHIND THE LANGUAGE SHIFTED TO THE WWW, THE ISSUES OF SPEED, PLATFORM INDEPENDENCE, AND SAFETY REMAINED, BUT THE IDEA OF DISTRIBUTED PROGRAMS BECAME EXTREMELY IMPORTANT.- ONE OF THE MAIN FEATURES JAVA PROVIDES IS THE REMOTE METHOD INVOCATION (RMI) SYSTEM, WHICH ALLOWS SEMI-TRANSPARENT METHOD INVOCATION AND EXCHANGE OF OBJECTS BETWEEN VIRTUAL MACHINES (EVEN ACROSS THE NETWORK)----- IN ADDITION TO THE RMI, OTHER GENERAL PROGRAMMING FEATURES SUPPORTED ARE EXCEPTIONS, GARBAGE COLLECTION (WHICH IS NOT ONLY SUPPORTED - BUT CONSIDERED CRUCIAL), BYTE CODE VERIFICATION (WHICH VALIDATES THE SAFETY OF A GIVEN PROGRAM), THREADS, METHOD OVERLOADING, AND PACKAGES (FOR-CREATING NAME SPACES) -----AS AN OBJECT ORIENTED LANGUAGE, JAVA SUPPORTS MULTIPLE LEVELS OF IMPLEMENTATION HIDING, PARTIALLY ABSTRACT CLASSES, FINAL CLASSES (WHICH CAN NOT BE INHERITED FROM) AND STATIC (CLASS) VARIABLES.----- SINGLE INHERITANCE OF CLASSES IS PROVIDED FOR SUBTYPEING AND CODE-SHARING, IN ADDITION TO MULTIPLE INHERITANCE OF ``INTERFACES'' - WHICH ACT AS TYPE DECLARATIONS, OR COMPLETELY ABSTRACT CLASSES.- AS OF VERSION 1.1, JAVA NOW ALSO SUPPORTS NESTED AND ANONYMOUS CLASSES.-------------------------------------------------------------- RESEARCH REFERENCES----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- FOOTNOTES:----------------------------------------------------------------------- BUT IN THEORY, WHAT REALLY MATTERS IS WHAT THE AUTHOR LEARNED.----------------------------------------------------------------- IT'S INTERESTING TO NOTE-- THAT ALTHOUGH MOST OF THE LITERATURE AGREES THAT A-- FEATURE TO INSPECT THE TYPE OF AN OBJECT AT RUN TIME-- IS CONTRARY TO THE OO PHILOSOPHY, THE SAME SOURCES ALL-- AGREE THAT DYNAMIC DISPATCH IS A MUST - BUT THE TWO-- FEATURES ARE EQUIVALENT. -----------------------------------------------------------------IN THE CASE OF GENERIC CLASS TEMPLATES, CLASS NAME EQUIVALENCE INCLUDES THE NAMES OF THE ACTUAL PARAMETERS-------------------------------------------